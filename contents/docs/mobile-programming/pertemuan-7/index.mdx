---
title: Pertemuan 7 - State Management dengan Hooks
description: Mempelajari pengelolaan state di React Native menggunakan React Hooks seperti useState, useEffect, useContext, dan custom hooks.
---

## ðŸ“Œ Pertemuan 7: State Management dengan Hooks

**State Management** adalah cara mengelola data yang berubah-ubah dalam aplikasi.  
React menyediakan **Hooks** yang memungkinkan kita mengelola state dan side effects dengan mudah di functional components.

---

### ðŸ”„ Apa itu State?

**State** adalah data yang dapat berubah dan mempengaruhi tampilan komponen.  
Ketika state berubah, React akan me-render ulang komponen tersebut.

```jsx
// Contoh state sederhana
const [count, setCount] = useState(0);
```

---

### ðŸŽ£ useState Hook

`useState` adalah hook paling dasar untuk mengelola state lokal.

```jsx
import React, { useState } from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';

export default function Counter() {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);
  const reset = () => setCount(0);

  return (
    <View style={styles.container}>
      <Text style={styles.countText}>Count: {count}</Text>
      
      <View style={styles.buttonContainer}>
        <TouchableOpacity style={styles.button} onPress={increment}>
          <Text style={styles.buttonText}>+</Text>
        </TouchableOpacity>
        
        <TouchableOpacity style={styles.button} onPress={decrement}>
          <Text style={styles.buttonText}>-</Text>
        </TouchableOpacity>
        
        <TouchableOpacity style={[styles.button, styles.resetButton]} onPress={reset}>
          <Text style={styles.buttonText}>Reset</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}
```

---

### ðŸ”¹ useState dengan Object & Array

```jsx
// State dengan Object
const [user, setUser] = useState({
  name: '',
  email: '',
  age: 0
});

const updateUser = (field, value) => {
  setUser(prevUser => ({
    ...prevUser,
    [field]: value
  }));
};

// State dengan Array
const [todos, setTodos] = useState([]);

const addTodo = (newTodo) => {
  setTodos(prevTodos => [...prevTodos, newTodo]);
};

const removeTodo = (id) => {
  setTodos(prevTodos => prevTodos.filter(todo => todo.id !== id));
};
```

---

### âš¡ useEffect Hook

`useEffect` digunakan untuk menangani **side effects** seperti API calls, subscriptions, atau cleanup.

```jsx
import React, { useState, useEffect } from 'react';
import { View, Text, ActivityIndicator } from 'react-native';

export default function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // Effect yang berjalan setelah component mount
  useEffect(() => {
    fetchUser();
  }, []); // Empty dependency array = hanya sekali

  // Effect yang berjalan ketika userId berubah
  useEffect(() => {
    if (userId) {
      fetchUser();
    }
  }, [userId]); // Dependency array dengan userId

  const fetchUser = async () => {
    try {
      setLoading(true);
      const response = await fetch(`/api/users/${userId}`);
      const userData = await response.json();
      setUser(userData);
    } catch (error) {
      console.error('Error fetching user:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return <ActivityIndicator size="large" />;
  }

  return (
    <View>
      <Text>Name: {user?.name}</Text>
      <Text>Email: {user?.email}</Text>
    </View>
  );
}
```

---

### ðŸ”¹ useEffect Cleanup

```jsx
useEffect(() => {
  // Setup subscription
  const subscription = someAPI.subscribe(data => {
    setData(data);
  });

  // Cleanup function
  return () => {
    subscription.unsubscribe();
  };
}, []);
```

---

### ðŸŒ useContext Hook

`useContext` memungkinkan sharing state antar komponen tanpa prop drilling.

#### 1. Membuat Context

```jsx
// contexts/ThemeContext.tsx
import React, { createContext, useContext, useState } from 'react';

const ThemeContext = createContext();

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
};

export const ThemeProvider = ({ children }) => {
  const [isDark, setIsDark] = useState(false);

  const toggleTheme = () => setIsDark(!isDark);

  const theme = {
    isDark,
    colors: {
      background: isDark ? '#000' : '#fff',
      text: isDark ? '#fff' : '#000',
      primary: '#007AFF',
    },
    toggleTheme,
  };

  return (
    <ThemeContext.Provider value={theme}>
      {children}
    </ThemeContext.Provider>
  );
};
```

#### 2. Menggunakan Context

```jsx
// App.tsx
import { ThemeProvider } from './contexts/ThemeContext';

export default function App() {
  return (
    <ThemeProvider>
      <MainScreen />
    </ThemeProvider>
  );
}

// MainScreen.tsx
import { useTheme } from './contexts/ThemeContext';

export default function MainScreen() {
  const { theme, toggleTheme } = useTheme();

  return (
    <View style={{ backgroundColor: theme.colors.background }}>
      <Text style={{ color: theme.colors.text }}>
        Current theme: {theme.isDark ? 'Dark' : 'Light'}
      </Text>
      <TouchableOpacity onPress={toggleTheme}>
        <Text>Toggle Theme</Text>
      </TouchableOpacity>
    </View>
  );
}
```

---

### ðŸ”§ useReducer Hook

`useReducer` berguna untuk state management yang lebih kompleks.

```jsx
import React, { useReducer } from 'react';

// Reducer function
const cartReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_ITEM':
      const existingItem = state.items.find(item => item.id === action.payload.id);
      if (existingItem) {
        return {
          ...state,
          items: state.items.map(item =>
            item.id === action.payload.id
              ? { ...item, quantity: item.quantity + 1 }
              : item
          )
        };
      }
      return {
        ...state,
        items: [...state.items, { ...action.payload, quantity: 1 }]
      };

    case 'REMOVE_ITEM':
      return {
        ...state,
        items: state.items.filter(item => item.id !== action.payload)
      };

    case 'CLEAR_CART':
      return { ...state, items: [] };

    default:
      return state;
  }
};

export default function ShoppingCart() {
  const [cart, dispatch] = useReducer(cartReducer, { items: [] });

  const addItem = (product) => {
    dispatch({ type: 'ADD_ITEM', payload: product });
  };

  const removeItem = (id) => {
    dispatch({ type: 'REMOVE_ITEM', payload: id });
  };

  const clearCart = () => {
    dispatch({ type: 'CLEAR_CART' });
  };

  return (
    <View>
      <Text>Cart Items: {cart.items.length}</Text>
      {/* Render cart items */}
    </View>
  );
}
```

---

### ðŸŽ¨ Custom Hooks

Custom hooks memungkinkan kita mengextract dan reuse stateful logic.

```jsx
// hooks/useApi.ts
import { useState, useEffect } from 'react';

export const useApi = (url) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);
        const response = await fetch(url);
        if (!response.ok) throw new Error('Failed to fetch');
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { data, loading, error };
};

// Penggunaan
export default function ProductList() {
  const { data: products, loading, error } = useApi('/api/products');

  if (loading) return <ActivityIndicator />;
  if (error) return <Text>Error: {error}</Text>;

  return (
    <FlatList
      data={products}
      renderItem={({ item }) => <ProductItem product={item} />}
    />
  );
}
```

---

### ðŸ”¹ Custom Hook untuk Form

```jsx
// hooks/useForm.ts
import { useState } from 'react';

export const useForm = (initialValues, validationRules = {}) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});

  const setValue = (name, value) => {
    setValues(prev => ({ ...prev, [name]: value }));
    
    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: null }));
    }
  };

  const validate = () => {
    const newErrors = {};
    
    Object.keys(validationRules).forEach(field => {
      const rule = validationRules[field];
      const value = values[field];
      
      if (rule.required && !value) {
        newErrors[field] = `${field} is required`;
      } else if (rule.minLength && value.length < rule.minLength) {
        newErrors[field] = `${field} must be at least ${rule.minLength} characters`;
      } else if (rule.pattern && !rule.pattern.test(value)) {
        newErrors[field] = rule.message || `${field} is invalid`;
      }
    });
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const reset = () => {
    setValues(initialValues);
    setErrors({});
  };

  return {
    values,
    errors,
    setValue,
    validate,
    reset
  };
};

// Penggunaan
export default function LoginForm() {
  const { values, errors, setValue, validate } = useForm(
    { email: '', password: '' },
    {
      email: {
        required: true,
        pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
        message: 'Please enter a valid email'
      },
      password: {
        required: true,
        minLength: 6
      }
    }
  );

  const handleSubmit = () => {
    if (validate()) {
      // Submit form
      console.log('Form submitted:', values);
    }
  };

  return (
    <View>
      <TextInput
        placeholder="Email"
        value={values.email}
        onChangeText={(text) => setValue('email', text)}
      />
      {errors.email && <Text style={styles.error}>{errors.email}</Text>}
      
      <TextInput
        placeholder="Password"
        secureTextEntry
        value={values.password}
        onChangeText={(text) => setValue('password', text)}
      />
      {errors.password && <Text style={styles.error}>{errors.password}</Text>}
      
      <TouchableOpacity onPress={handleSubmit}>
        <Text>Login</Text>
      </TouchableOpacity>
    </View>
  );
}
```

---

### ðŸŽ¯ Studi Kasus: Todo App dengan Hooks

```jsx
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, TouchableOpacity, FlatList } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

export default function TodoApp() {
  const [todos, setTodos] = useState([]);
  const [inputText, setInputText] = useState('');

  // Load todos from storage
  useEffect(() => {
    loadTodos();
  }, []);

  // Save todos to storage whenever todos change
  useEffect(() => {
    saveTodos();
  }, [todos]);

  const loadTodos = async () => {
    try {
      const savedTodos = await AsyncStorage.getItem('todos');
      if (savedTodos) {
        setTodos(JSON.parse(savedTodos));
      }
    } catch (error) {
      console.error('Error loading todos:', error);
    }
  };

  const saveTodos = async () => {
    try {
      await AsyncStorage.setItem('todos', JSON.stringify(todos));
    } catch (error) {
      console.error('Error saving todos:', error);
    }
  };

  const addTodo = () => {
    if (inputText.trim()) {
      const newTodo = {
        id: Date.now().toString(),
        text: inputText.trim(),
        completed: false,
        createdAt: new Date().toISOString()
      };
      setTodos(prev => [...prev, newTodo]);
      setInputText('');
    }
  };

  const toggleTodo = (id) => {
    setTodos(prev =>
      prev.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );
  };

  const deleteTodo = (id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  };

  return (
    <View style={styles.container}>
      <View style={styles.inputContainer}>
        <TextInput
          style={styles.input}
          value={inputText}
          onChangeText={setInputText}
          placeholder="Add new todo..."
          onSubmitEditing={addTodo}
        />
        <TouchableOpacity style={styles.addButton} onPress={addTodo}>
          <Text style={styles.addButtonText}>Add</Text>
        </TouchableOpacity>
      </View>

      <FlatList
        data={todos}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <TodoItem
            todo={item}
            onToggle={() => toggleTodo(item.id)}
            onDelete={() => deleteTodo(item.id)}
          />
        )}
      />
    </View>
  );
}
```

---

### ðŸŽ¯ Latihan

1. **Counter App** â†’ Buat counter dengan increment, decrement, dan reset
2. **Form dengan Validation** â†’ Implementasi form login dengan custom hook
3. **Theme Switcher** â†’ Buat context untuk dark/light mode
4. **Shopping Cart** â†’ Gunakan useReducer untuk mengelola cart state
5. **Todo App** â†’ Buat todo app lengkap dengan persistence

**Best Practices:**
- Gunakan `useState` untuk state sederhana
- Gunakan `useReducer` untuk state kompleks
- Buat custom hooks untuk logic yang reusable
- Gunakan `useContext` untuk global state
- Selalu cleanup di `useEffect` jika diperlukan