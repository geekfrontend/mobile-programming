---
title: Pertemuan 2 - TypeScript Lanjutan
description: Memahami tipe data lanjutan seperti Array, Object, Interface, dan Generic di TypeScript.
---

## üìå Pertemuan 2: TypeScript Lanjutan

Setelah memahami dasar TypeScript, kita melangkah ke fitur yang membantu menjaga kode tetap terstruktur, fleksibel, dan siap skala besar.

---

### üéØ Tujuan Pembelajaran

- Menggunakan `interface`, `type`, dan `enum` secara efektif.  
- Mengelola struktur data kompleks (array, tuple, nested object).  
- Memanfaatkan generic untuk membuat fungsi/komponen reusable.  
- Memahami teknik narrowing dan utility types untuk menangani data dinamis.

---

### ‚ôªÔ∏è Reviu Singkat

- Array: `let numbers: number[] = [1, 2, 3];`  
- Object literal: `let student: { name: string; age: number } = { ... };`  
- Function annotation: `function greet(name: string): string`.

---

### üß† Materi Utama

#### 1. Interface & Type Alias

```ts
interface User {
  name: string;
  age: number;
  isActive: boolean;
}

const user1: User = {
  name: "Sarah",
  age: 22,
  isActive: true,
};

interface Admin extends User {
  permissions: string[];
}

type Coordinates = [number, number];
type UserRole = "ADMIN" | "EDITOR" | "VIEWER";
```

Gunakan `interface` ketika butuh ekspansi (extend/implement). `type` fleksibel untuk union, intersection, dan tuple.

#### 2. Object Composition & Nested Types

```ts
type Product = {
  id: string;
  name: string;
  price: number;
  stock: number;
  metadata?: {
    tags: string[];
    lastUpdated: Date;
  };
};

const catalog: Product[] = [
  {
    id: "p-1",
    name: "Learning React Native",
    price: 75000,
    stock: 10,
    metadata: {
      tags: ["book", "mobile"],
      lastUpdated: new Date(),
    },
  },
];

function printProduct(product: Product): void {
  console.log(`${product.name} - Rp${product.price}`);
  if (product.metadata?.tags) {
    console.log(`Tags: ${product.metadata.tags.join(", ")}`);
  }
}
```

#### 3. Generic Function & Generic Type

```ts
function wrap<T>(value: T): T[] {
  return [value];
}

const stringResult = wrap<string>("Hello");
const numberResult = wrap(123); // infer: number

type ApiResponse<T> = {
  data: T;
  status: number;
  error?: string;
};

const userResponse: ApiResponse<User> = {
  data: user1,
  status: 200,
};
```

Generic membantu membuat utilitas reusable tanpa kehilangan keamanan tipe.

#### 4. Union, Intersection, dan Enum

```ts
enum Category {
  BOOK = "BOOK",
  ELECTRONICS = "ELECTRONICS",
  FASHION = "FASHION",
}

type BaseProduct = { id: string; name: string; price: number };
type Stockable = { stock: number };
type Discountable = { discount?: number };

type StoreProduct = BaseProduct & Stockable & {
  category: Category;
};

function calculateFinalPrice(
  product: StoreProduct & Discountable
): number {
  const discountMultiplier = 1 - (product.discount ?? 0);
  return product.price * discountMultiplier;
}
```

Enums membantu standardisasi nilai tetap, sedangkan union/intersection memodelkan tipe kompleks.

#### 5. Type Narrowing & Type Assertion

```ts
type Result = string | number;

function formatResult(result: Result): string {
  if (typeof result === "number") {
    return result.toFixed(2);
  }
  return result.toUpperCase();
}

function getElement(id: string) {
  const element = document.getElementById(id);
  return element as HTMLInputElement | null;
}
```

Gunakan **narrowing** untuk memastikan tipe spesifik sebelum mengakses properti, dan gunakan **assertion** dengan hati-hati ketika yakin tipe tertentu.

#### 6. Utility Types Populer

```ts
type ProductPreview = Pick<Product, "id" | "name" | "price">;
type ProductPayload = Omit<Product, "metadata" | "stock">;
type ReadonlyProduct = Readonly<Product>;
type ProductUpdate = Partial<Product>;
```

Utility types membantu memodifikasi tipe yang sudah ada tanpa menulis ulang.

---

### üß™ Latihan Terarah

1. Buat `interface Product` dengan field `id`, `name`, `price`, `stock`, dan `category`.  
2. Implementasikan fungsi `printProducts(products: Product[]): void` yang menampilkan daftar produk dengan format rapi.  
3. Buat `type CreateProductPayload = Omit<Product, "id" | "stock"> & { stock?: number }` dan buat fungsi `createProduct(payload: CreateProductPayload): Product`.  
4. Tambahkan `enum Category` (`BOOK`, `ELECTRONICS`, `FASHION`) dan gunakan pada data produk.  
5. Buat fungsi `filter<T>(items: T[], predicate: (item: T) => boolean): T[]` untuk melatih generic.  
6. (Opsional) Implementasikan `type ApiState<T> = { status: "idle" | "loading" | "success" | "error"; data?: T; error?: string };` lalu buat fungsi `createSuccessState<T>(data: T): ApiState<T>`.

---

### üìé Referensi Cepat

- Handbook TypeScript Advanced Types: https://www.typescriptlang.org/docs/handbook/2/types-from-types.html  
- Utility Types: https://www.typescriptlang.org/docs/handbook/utility-types.html  
- TypeScript Deep Dive (gratis): https://basarat.gitbook.io/typescript/
